<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>äº”å­æ£‹æ¸¸æˆ</title>
<style>
    body {
        font-family: 'Arial', sans-serif; /* ä½¿ç”¨é€šç”¨å­—ä½“ */
        display: flex;
        flex-direction: column;
        align-items: center; /* æ°´å¹³å±…ä¸­ */
        justify-content: center; /* å‚ç›´å±…ä¸­ */
        margin: 0;
        /* padding-top: 20px; -- Removed for true vertical centering */
        background-color: #f0f8ff; /* æ·¡é›…çš„èƒŒæ™¯è‰² */
        color: #333;
        min-height: 100vh;
        box-sizing: border-box;
    }
    h1 {
        color: #2c3e50; /* æ·±è“ç°è‰²æ ‡é¢˜ */
        margin-top: 0; /* Adjust if needed after centering */
        margin-bottom: 20px; /* Add some space below title */
    }
    #gameContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #ffffff;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    #gameBoard {
        border: 2px solid #795548; /* æ£•è‰²è¾¹æ¡†ï¼Œåƒæœ¨å¤´ */
        background-color: #deb887; /* æ£‹ç›˜æœ¨è‰² */
        cursor: pointer;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.1); /* æ£‹ç›˜å†…é˜´å½±å¢åŠ è´¨æ„Ÿ */
        touch-action: none; /* ç¦ç”¨è§¦æ‘¸æ»šåŠ¨ç­‰ï¼Œä¼˜åŒ–ç§»åŠ¨ç«¯ä½“éªŒ */
    }
    #statusMessage {
        font-size: 1.2em;
        margin-top: 20px;
        margin-bottom: 15px;
        color: #34495e; /* è¾ƒæ·±çš„æ–‡æœ¬é¢œè‰² */
        font-weight: bold;
        min-height: 1.5em; /* é˜²æ­¢æ–‡å­—å˜åŒ–æ—¶å¸ƒå±€è·³åŠ¨ */
        text-align: center;
    }
    #resetButton {
        margin-top: 15px;
        padding: 12px 25px;
        font-size: 1em;
        cursor: pointer;
        background-color: #3498db; /* æ¸…çˆ½çš„è“è‰² */
        color: white;
        border: none;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        transition: background-color 0.3s ease, transform 0.1s ease;
    }
    #resetButton:hover {
        background-color: #2980b9; /* æ‚¬åœæ—¶é¢œè‰²åŠ æ·± */
    }
    #resetButton:active {
        transform: scale(0.98); /* ç‚¹å‡»æ—¶è½»å¾®ç¼©å° */
    }

    /* å“åº”å¼è°ƒæ•´ */
    @media (max-width: 600px) {
        #gameContainer {
            padding: 15px;
            margin-left: 10px;
            margin-right: 10px;
            width: calc(100% - 20px); /* Ensure it doesn't overflow small screens */
            box-sizing: border-box;
        }
        h1 {
            font-size: 1.8em;
        }
        #statusMessage {
            font-size: 1.1em;
        }
        #resetButton {
            padding: 10px 20px;
            font-size: 0.9em;
        }
        /* æ£‹ç›˜å¤§å°ä¼šç”±JSåŠ¨æ€è°ƒæ•´ */
    }
</style>
</head>
<body>

<div id="gameContainer">
    <h1>äº”å­æ£‹</h1>
    <canvas id="gameBoard"></canvas>
    <p id="statusMessage">é»‘æ£‹å…ˆè¡Œ</p>
    <button id="resetButton">é‡æ–°å¼€å§‹</button>
</div>

<script>
    // è·å–DOMå…ƒç´ 
    const canvas = document.getElementById('gameBoard');
    const ctx = canvas.getContext('2d');
    const statusMessage = document.getElementById('statusMessage');
    const resetButton = document.getElementById('resetButton');
    const gameContainer = document.getElementById('gameContainer');

    // æ¸¸æˆå‚æ•°é…ç½®
    const BOARD_LINES = 15; // æ£‹ç›˜çº¿æ¡æ•° (15x15 çš„æ£‹ç›˜æœ‰ 14x14 ä¸ªæ ¼å­ï¼Œ15x15ä¸ªäº¤å‰ç‚¹)
    let CELL_SIZE; // æ¯ä¸ªæ ¼å­çš„åƒç´ å¤§å°ï¼Œå°†åŠ¨æ€è®¡ç®—
    let MARGIN;    // æ£‹ç›˜è¾¹ç¼˜çš„ç©ºç™½åŒºåŸŸï¼Œå°†åŠ¨æ€è®¡ç®—
    let PIECE_RADIUS; // æ£‹å­åŠå¾„ï¼Œå°†åŠ¨æ€è®¡ç®—

    // æ¸¸æˆçŠ¶æ€å˜é‡
    let board = []; // æ£‹ç›˜çŠ¶æ€: 0: ç©º, 1: é»‘æ£‹, 2: ç™½æ£‹
    let currentPlayer = 1; // 1 ä»£è¡¨é»‘æ£‹, 2 ä»£è¡¨ç™½æ£‹
    let gameOver = false;
    let lastMove = null; // è®°å½•æœ€åä¸€æ­¥æ£‹çš„ä½ç½® {row, col} ç”¨äºé«˜äº®

    // åŠ¨æ€è°ƒæ•´æ£‹ç›˜å¤§å°
    function resizeCanvas() {
        // å®¹å™¨å†…å¯ç”¨å®½åº¦ï¼Œå‡å»å®¹å™¨çš„paddingå’Œä¸€äº›é¢å¤–è¾¹è·
        const containerInnerWidth = gameContainer.clientWidth - parseInt(getComputedStyle(gameContainer).paddingLeft) - parseInt(getComputedStyle(gameContainer).paddingRight);
        // è€ƒè™‘çª—å£é«˜åº¦ï¼Œç¡®ä¿æ£‹ç›˜ä¸ä¼šå¤ªé«˜è€Œæ— æ³•æ˜¾ç¤º
        const availableHeightForCanvas = window.innerHeight - (statusMessage.offsetHeight + resetButton.offsetHeight + document.querySelector('h1').offsetHeight + 100); // 100 for margins/paddings

        const maxCanvasSizeFromWidth = containerInnerWidth * 0.95; // ä½¿ç”¨95%çš„å®¹å™¨å®½åº¦
        const maxCanvasSizeFromHeight = availableHeightForCanvas * 0.95; // ä½¿ç”¨95%çš„å¯ç”¨é«˜åº¦

        const targetCanvasSize = Math.min(maxCanvasSizeFromWidth, maxCanvasSizeFromHeight, 500); // é™åˆ¶æœ€å¤§å®½åº¦ï¼Œå¹¶è€ƒè™‘é«˜åº¦

        CELL_SIZE = Math.floor(targetCanvasSize / (BOARD_LINES + 0.5)); // è°ƒæ•´åˆ†æ¯ä»¥å¾®è°ƒè¾¹è·æ„Ÿ
        MARGIN = CELL_SIZE * 0.75; // è°ƒæ•´å¤–è¾¹è·æ¯”ä¾‹
        PIECE_RADIUS = CELL_SIZE / 2 * 0.85; // æ£‹å­ç¨å°ä¸€ç‚¹

        canvas.width = (BOARD_LINES - 1) * CELL_SIZE + 2 * MARGIN;
        canvas.height = (BOARD_LINES - 1) * CELL_SIZE + 2 * MARGIN;

        drawBoard(); // é‡æ–°ç»˜åˆ¶æ£‹ç›˜å’Œæ£‹å­
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    function initGame() {
        board = Array(BOARD_LINES).fill(null).map(() => Array(BOARD_LINES).fill(0));
        currentPlayer = 1;
        gameOver = false;
        lastMove = null;
        statusMessage.textContent = "è½®åˆ°é»‘æ£‹";
        resizeCanvas(); // åˆå§‹åŒ–æ—¶è°ƒæ•´å¤§å°å¹¶ç»˜åˆ¶
    }

    // ç»˜åˆ¶æ£‹ç›˜èƒŒæ™¯å’Œçº¿æ¡
    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ç»˜åˆ¶ç½‘æ ¼çº¿
        ctx.strokeStyle = "#543A29"; // æ·±æ£•è‰²çº¿æ¡
        ctx.lineWidth = 1;
        for (let i = 0; i < BOARD_LINES; i++) {
            // æ¨ªçº¿
            ctx.beginPath();
            ctx.moveTo(MARGIN + i * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + i * CELL_SIZE, MARGIN + (BOARD_LINES - 1) * CELL_SIZE);
            ctx.stroke();
            // ç«–çº¿
            ctx.beginPath();
            ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
            ctx.lineTo(MARGIN + (BOARD_LINES - 1) * CELL_SIZE, MARGIN + i * CELL_SIZE);
            ctx.stroke();
        }

        // ç»˜åˆ¶æ£‹ç›˜ä¸Šçš„æ˜Ÿä½ï¼ˆå¤©å…ƒå’Œè§’ä¸Šçš„ç‚¹ï¼‰
        const starPointsDefinition = [ // (0-indexed)
            {r: 3, c: 3}, {r: 3, c: 11},
            {r: 11, c: 3}, {r: 11, c: 11},
            {r: 7, c: 7} // å¤©å…ƒ
        ];
        if (BOARD_LINES === 15) { // ä»…ä¸º15x15æ£‹ç›˜ç»˜åˆ¶æ ‡å‡†æ˜Ÿä½
             starPointsDefinition.push({r:3, c:7}, {r:7, c:3}, {r:7, c:11}, {r:11, c:7});
        }

        ctx.fillStyle = "#543A29"; // æ˜Ÿä½ç‚¹é¢œè‰²
        starPointsDefinition.forEach(point => {
            if (point.r < BOARD_LINES && point.c < BOARD_LINES) {
                ctx.beginPath();
                ctx.arc(MARGIN + point.c * CELL_SIZE, MARGIN + point.r * CELL_SIZE, CELL_SIZE * 0.1, 0, 2 * Math.PI);
                ctx.fill();
            }
        });

        // é‡æ–°ç»˜åˆ¶æ‰€æœ‰æ£‹å­
        for (let r = 0; r < BOARD_LINES; r++) {
            for (let c = 0; c < BOARD_LINES; c++) {
                if (board[r][c] !== 0) {
                    drawPiece(r, c, board[r][c]);
                }
            }
        }

        // é«˜äº®æœ€åä¸€æ­¥æ£‹
        if (lastMove) {
            highlightLastMove(lastMove.row, lastMove.col);
        }
    }

    // ç»˜åˆ¶å•ä¸ªæ£‹å­
    function drawPiece(row, col, player) {
        const x = MARGIN + col * CELL_SIZE;
        const y = MARGIN + row * CELL_SIZE;

        ctx.beginPath();
        ctx.arc(x, y, PIECE_RADIUS, 0, 2 * Math.PI);
        
        // æ·»åŠ æ¸å˜æ•ˆæœä½¿æ£‹å­æ›´ç«‹ä½“
        const gradient = ctx.createRadialGradient(x - PIECE_RADIUS/3, y - PIECE_RADIUS/3, PIECE_RADIUS/4, x, y, PIECE_RADIUS);
        if (player === 1) { // é»‘æ£‹
            gradient.addColorStop(0, '#555');
            gradient.addColorStop(1, '#000');
            ctx.fillStyle = gradient;
        } else { // ç™½æ£‹
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(1, '#ccc');
            ctx.fillStyle = gradient;
        }
        ctx.fill();
    }

    // é«˜äº®æ˜¾ç¤ºæœ€åä¸€æ­¥æ£‹
    function highlightLastMove(row, col) {
        const x = MARGIN + col * CELL_SIZE;
        const y = MARGIN + row * CELL_SIZE;
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, PIECE_RADIUS + 2, 0, 2 * Math.PI); // æ¯”æ£‹å­ç¨å¤§çš„çº¢è‰²åœ†åœˆ
        ctx.stroke();
    }


    // å¤„ç†ç‚¹å‡»äº‹ä»¶ (åŒæ—¶å…¼å®¹è§¦æ‘¸äº‹ä»¶)
    function handleBoardInteraction(event) {
        if (gameOver) return;

        event.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå¦‚é¡µé¢æ»šåŠ¨

        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        const canvasX = clientX - rect.left;
        const canvasY = clientY - rect.top;

        // è®¡ç®—ç‚¹å‡»çš„æ˜¯å“ªä¸ªäº¤å‰ç‚¹ (å››èˆäº”å…¥åˆ°æœ€è¿‘çš„äº¤å‰ç‚¹)
        const col = Math.round((canvasX - MARGIN) / CELL_SIZE);
        const row = Math.round((canvasY - MARGIN) / CELL_SIZE);

        // è¾¹ç•Œæ£€æŸ¥ï¼Œç¡®ä¿è¡Œåˆ—å€¼åœ¨æœ‰æ•ˆèŒƒå›´å†…
        if (col < 0 || col >= BOARD_LINES || row < 0 || row >= BOARD_LINES) {
            return; // ç‚¹å‡»åœ¨æ£‹ç›˜å¤–æˆ–æ— æ•ˆåŒºåŸŸ
        }
        // ç¡®ä¿ CELL_SIZE > 0 é¿å…é™¤é›¶é”™è¯¯
        if (CELL_SIZE <= 0) return;


        if (board[row][col] === 0) { // åªèƒ½åœ¨ç©ºä½ä¸‹æ£‹
            board[row][col] = currentPlayer;
            lastMove = {row, col}; // è®°å½•æœ€åä¸€æ­¥
            drawBoard(); // é‡ç»˜æ£‹ç›˜ä»¥æ˜¾ç¤ºæ–°æ£‹å­å’Œé«˜äº®

            if (checkWin(row, col, currentPlayer)) {
                gameOver = true;
                statusMessage.textContent = (currentPlayer === 1 ? "é»‘æ£‹" : "ç™½æ£‹") + "èƒœåˆ©ï¼ğŸ‰";
                return;
            }

            if (checkDraw()) {
                gameOver = true;
                statusMessage.textContent = "å¹³å±€ï¼ğŸ¤";
                return;
            }

            currentPlayer = (currentPlayer === 1) ? 2 : 1;
            statusMessage.textContent = "è½®åˆ°" + (currentPlayer === 1 ? "é»‘æ£‹" : "ç™½æ£‹");
        }
    }

    // æ£€æŸ¥æ˜¯å¦è·èƒœ
    function checkWin(row, col, player) {
        // æ–¹å‘æ•°ç»„: [æ°´å¹³, å‚ç›´, å³æ–œ(/), å·¦æ–œ(\)]
        // æ¯ä¸ªå…ƒç´ æ˜¯ [rowIncrement, colIncrement]
        const directions = [
            [0, 1],  // æ°´å¹³ (æ£€æŸ¥å·¦å³)
            [1, 0],  // å‚ç›´ (æ£€æŸ¥ä¸Šä¸‹)
            [1, 1],  // å·¦ä¸‹åˆ°å³ä¸Š (\)
            [1, -1]  // å·¦ä¸Šåˆ°å³ä¸‹ (/)
        ];

        for (let dir of directions) {
            let count = 1; // å½“å‰è½å­ç®—ä¸€ä¸ª
            // æ£€æŸ¥ä¸€ä¸ªæ–¹å‘
            for (let i = 1; i < 5; i++) {
                const r = row + dir[0] * i;
                const c = col + dir[1] * i;
                if (r >= 0 && r < BOARD_LINES && c >= 0 && c < BOARD_LINES && board[r][c] === player) {
                    count++;
                } else {
                    break; 
                }
            }
            // æ£€æŸ¥ç›¸åæ–¹å‘
            for (let i = 1; i < 5; i++) {
                const r = row - dir[0] * i;
                const c = col - dir[1] * i;
                if (r >= 0 && r < BOARD_LINES && c >= 0 && c < BOARD_LINES && board[r][c] === player) {
                    count++;
                } else {
                    break;
                }
            }
            if (count >= 5) return true; 
        }
        return false;
    }

    // æ£€æŸ¥æ˜¯å¦å¹³å±€
    function checkDraw() {
        for (let r = 0; r < BOARD_LINES; r++) {
            for (let c = 0; c < BOARD_LINES; c++) {
                if (board[r][c] === 0) {
                    return false; 
                }
            }
        }
        return true; 
    }

    // äº‹ä»¶ç›‘å¬
    canvas.addEventListener('click', handleBoardInteraction);
    canvas.addEventListener('touchstart', handleBoardInteraction, { passive: false }); 
    resetButton.addEventListener('click', initGame);
    window.addEventListener('resize', resizeCanvas); 

    // å¯åŠ¨æ¸¸æˆ
    initGame();

</script>

</body>
</html>
