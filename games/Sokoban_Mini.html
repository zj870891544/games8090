<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Êé®ÁÆ±Â≠êËø∑‰Ω†Áâà</title>
  <style>
    :root {
      --bg: #101a12;
      --panel: #1a2a1d;
      --line: #34513a;
      --text: #e8f7e9;
      --muted: #a6c8a8;
      --wall: #2f4732;
      --floor: #243727;
      --target: #f59e0b;
      --box: #b08968;
      --box-on: #34d399;
      --player: #60a5fa;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 16px;
      background: radial-gradient(circle at 18% 8%, #27442d, var(--bg) 50%);
      color: var(--text);
      font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
    }

    .wrap {
      width: min(720px, 100%);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.35);
    }

    .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .chip {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 5px 10px;
      color: var(--muted);
      font-size: 14px;
    }

    .chip strong { margin-left: 4px; color: var(--text); }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid #567a5d;
      background: #2a4430;
      color: #ebf7ee;
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      font: inherit;
      font-weight: 600;
    }

    button:hover { border-color: #7fa587; }

    .board-shell {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #132116;
      padding: 10px;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(var(--cols), minmax(0, 1fr));
      gap: 6px;
      max-width: 540px;
      margin: 0 auto;
    }

    .cell {
      aspect-ratio: 1 / 1;
      border-radius: 8px;
      display: grid;
      place-items: center;
      font-size: clamp(16px, 3vw, 24px);
      user-select: none;
    }

    .wall { background: var(--wall); }
    .floor { background: var(--floor); }
    .target { box-shadow: inset 0 0 0 2px rgba(245, 158, 11, 0.9); }
    .box { background: linear-gradient(160deg, #c4a484, var(--box)); color: #2f1f12; }
    .box.on { background: linear-gradient(160deg, #6ee7b7, var(--box-on)); color: #0e2e22; }
    .player { color: var(--player); }

    .status {
      min-height: 24px;
      text-align: center;
      color: var(--muted);
      margin-top: 10px;
      font-size: 14px;
    }

    .status.win { color: #6ee7b7; font-weight: 700; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="stats">
        <div class="chip">ÂÖ≥Âç°<strong id="levelLabel">1</strong></div>
        <div class="chip">Ê≠•Êï∞<strong id="stepsLabel">0</strong></div>
        <div class="chip">Êí§ÈîÄ<strong id="undoLabel">0</strong></div>
      </div>
      <div class="actions">
        <button id="prevBtn">‰∏ä‰∏ÄÂÖ≥</button>
        <button id="nextBtn">‰∏ã‰∏ÄÂÖ≥</button>
        <button id="restartBtn">ÈáçÁΩÆÊú¨ÂÖ≥</button>
        <button id="undoBtn">Êí§ÈîÄ</button>
      </div>
    </div>

    <div class="board-shell">
      <div class="board" id="board"></div>
      <div class="status" id="status">ÊñπÂêëÈîÆÊàñ WASD ÁßªÂä®ÔºåÊé®Âä®ÁÆ±Â≠êÂà∞ÁõÆÊ†áÁÇπ„ÄÇ</div>
    </div>
  </div>

  <script>
    (() => {
      const levels = [
        [
          "########",
          "#  .   #",
          "#  $   #",
          "#  $ . #",
          "#  @   #",
          "########"
        ],
        [
          "#########",
          "#   .   #",
          "# $$#   #",
          "#  @# . #",
          "#   #   #",
          "#########"
        ],
        [
          "##########",
          "# .   .  #",
          "# $$ $$  #",
          "#   @    #",
          "#   ##   #",
          "##########"
        ]
      ];

      const boardEl = document.getElementById("board");
      const levelLabel = document.getElementById("levelLabel");
      const stepsLabel = document.getElementById("stepsLabel");
      const undoLabel = document.getElementById("undoLabel");
      const statusEl = document.getElementById("status");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const restartBtn = document.getElementById("restartBtn");
      const undoBtn = document.getElementById("undoBtn");

      let levelIndex = 0;
      let rows = 0;
      let cols = 0;
      let grid = [];
      let targets = new Set();
      let player = { x: 0, y: 0 };
      let steps = 0;
      let history = [];
      let solved = false;

      function key(x, y) {
        return `${x},${y}`;
      }

      function setStatus(text, win = false) {
        statusEl.textContent = text;
        statusEl.className = win ? "status win" : "status";
      }

      function cloneState() {
        return {
          grid: grid.map((row) => row.slice()),
          player: { ...player },
          steps
        };
      }

      function restoreState(state) {
        grid = state.grid.map((row) => row.slice());
        player = { ...state.player };
        steps = state.steps;
      }

      function loadLevel(index) {
        const raw = levels[index];
        rows = raw.length;
        cols = Math.max(...raw.map((line) => line.length));
        grid = Array.from({ length: rows }, (_, y) =>
          Array.from({ length: cols }, (_, x) => raw[y][x] || " ")
        );

        targets = new Set();
        for (let y = 0; y < rows; y += 1) {
          for (let x = 0; x < cols; x += 1) {
            const c = grid[y][x];
            if (c === "." || c === "+" || c === "*") {
              targets.add(key(x, y));
            }
            if (c === "@" || c === "+") {
              player = { x, y };
              grid[y][x] = " ";
            } else if (c === "*") {
              grid[y][x] = "$";
            }
          }
        }

        steps = 0;
        history = [];
        solved = false;
        levelLabel.textContent = String(levelIndex + 1);
        syncStats();
        render();
        setStatus("ÊñπÂêëÈîÆÊàñ WASD ÁßªÂä®ÔºåÊé®Âä®ÁÆ±Â≠êÂà∞ÁõÆÊ†áÁÇπ„ÄÇ");
      }

      function isWall(x, y) {
        return x < 0 || y < 0 || x >= cols || y >= rows || grid[y][x] === "#";
      }

      function hasBox(x, y) {
        return grid[y][x] === "$";
      }

      function isTarget(x, y) {
        return targets.has(key(x, y));
      }

      function isSolved() {
        for (const t of targets) {
          const [x, y] = t.split(",").map(Number);
          if (!hasBox(x, y)) return false;
        }
        return true;
      }

      function syncStats() {
        stepsLabel.textContent = String(steps);
        undoLabel.textContent = String(history.length);
      }

      function render() {
        boardEl.style.setProperty("--cols", String(cols));
        boardEl.innerHTML = "";
        for (let y = 0; y < rows; y += 1) {
          for (let x = 0; x < cols; x += 1) {
            const cell = document.createElement("div");
            const c = grid[y][x];
            const target = isTarget(x, y);
            const isPlayer = player.x === x && player.y === y;
            const has = c === "$";
            cell.className = "cell " + (c === "#" ? "wall" : "floor");
            if (target) cell.classList.add("target");
            if (has) {
              cell.classList.add("box");
              if (target) cell.classList.add("on");
              cell.textContent = target ? "‚óÜ" : "‚ñ†";
            } else if (isPlayer) {
              cell.classList.add("player");
              cell.textContent = "üôÇ";
            } else if (target) {
              cell.textContent = "‚óé";
            }
            boardEl.appendChild(cell);
          }
        }
      }

      function move(dx, dy) {
        if (solved) return;
        const nx = player.x + dx;
        const ny = player.y + dy;
        if (isWall(nx, ny)) return;

        history.push(cloneState());

        if (hasBox(nx, ny)) {
          const bx = nx + dx;
          const by = ny + dy;
          if (isWall(bx, by) || hasBox(bx, by)) {
            history.pop();
            return;
          }
          grid[by][bx] = "$";
          grid[ny][nx] = " ";
        }

        player = { x: nx, y: ny };
        steps += 1;
        syncStats();
        render();

        if (isSolved()) {
          solved = true;
          setStatus(`Á¨¨ ${levelIndex + 1} ÂÖ≥ÂÆåÊàêÔºåÁî®‰∫Ü ${steps} Ê≠•„ÄÇ`, true);
        }
      }

      function undo() {
        if (!history.length || solved) return;
        const prev = history.pop();
        restoreState(prev);
        syncStats();
        render();
      }

      function changeLevel(delta) {
        levelIndex = (levelIndex + delta + levels.length) % levels.length;
        loadLevel(levelIndex);
      }

      document.addEventListener("keydown", (event) => {
        const keyCode = event.key.toLowerCase();
        const map = {
          arrowup: [0, -1],
          w: [0, -1],
          arrowdown: [0, 1],
          s: [0, 1],
          arrowleft: [-1, 0],
          a: [-1, 0],
          arrowright: [1, 0],
          d: [1, 0]
        };
        if (keyCode === "z") {
          undo();
          return;
        }
        const dir = map[keyCode];
        if (!dir) return;
        event.preventDefault();
        move(dir[0], dir[1]);
      });

      prevBtn.addEventListener("click", () => changeLevel(-1));
      nextBtn.addEventListener("click", () => changeLevel(1));
      restartBtn.addEventListener("click", () => loadLevel(levelIndex));
      undoBtn.addEventListener("click", undo);

      loadLevel(levelIndex);
    })();
  </script>
</body>
</html>
