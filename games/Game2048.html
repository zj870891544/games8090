<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>2048 经典版</title>
  <style>
    :root {
      --bg: #f4efe6;
      --panel: #faf6ee;
      --board: #b7ab9f;
      --cell: #cdc1b4;
      --text: #5f5246;
      --text-light: #f9f6f2;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 16px;
      background: radial-gradient(circle at 20% 5%, #fff7ea, var(--bg) 42%);
      font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
      color: var(--text);
    }

    .wrap {
      width: min(520px, 100%);
      background: var(--panel);
      border-radius: 18px;
      box-shadow: 0 16px 36px rgba(40, 28, 13, 0.18);
      padding: 16px;
      border: 1px solid #e9dfd2;
    }

    .head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    h1 {
      margin: 0;
      font-size: 36px;
      line-height: 1;
    }

    .stats {
      display: flex;
      gap: 8px;
    }

    .score-box {
      min-width: 76px;
      text-align: center;
      background: #bbada0;
      color: var(--text-light);
      border-radius: 9px;
      padding: 7px 9px;
      font-size: 12px;
      font-weight: 600;
    }

    .score-box strong {
      display: block;
      font-size: 22px;
      margin-top: 2px;
      line-height: 1;
    }

    .toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 12px;
      color: #776e65;
    }

    button {
      border: 0;
      border-radius: 10px;
      background: #8f7a66;
      color: #fff;
      padding: 8px 12px;
      font: inherit;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover { background: #7d6957; }

    .board-wrap {
      position: relative;
      width: min(440px, 100%);
      margin-inline: auto;
    }

    .board-bg,
    .board-tiles {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 10px;
      border-radius: 10px;
    }

    .board-bg {
      background: var(--board);
      padding: 10px;
      aspect-ratio: 1 / 1;
    }

    .board-tiles {
      position: absolute;
      inset: 10px;
      gap: 10px;
      pointer-events: none;
    }

    .bg-cell {
      border-radius: 8px;
      background: var(--cell);
    }

    .tile {
      display: grid;
      place-items: center;
      border-radius: 8px;
      font-weight: 800;
      font-size: clamp(16px, 4.2vw, 32px);
      transition: transform 100ms ease;
      user-select: none;
    }

    .v-0 { background: transparent; color: transparent; }
    .v-2 { background: #eee4da; color: #776e65; }
    .v-4 { background: #ede0c8; color: #776e65; }
    .v-8 { background: #f2b179; color: #f9f6f2; }
    .v-16 { background: #f59563; color: #f9f6f2; }
    .v-32 { background: #f67c5f; color: #f9f6f2; }
    .v-64 { background: #f65e3b; color: #f9f6f2; }
    .v-128 { background: #edcf72; color: #f9f6f2; font-size: clamp(15px, 4vw, 28px); }
    .v-256 { background: #edcc61; color: #f9f6f2; font-size: clamp(15px, 4vw, 28px); }
    .v-512 { background: #edc850; color: #f9f6f2; font-size: clamp(14px, 3.8vw, 26px); }
    .v-1024 { background: #edc53f; color: #f9f6f2; font-size: clamp(12px, 3.3vw, 22px); }
    .v-2048 { background: #edc22e; color: #f9f6f2; font-size: clamp(12px, 3.3vw, 22px); }
    .v-max { background: #3c3a32; color: #f9f6f2; font-size: clamp(12px, 3.3vw, 22px); }

    .message {
      margin-top: 10px;
      min-height: 24px;
      text-align: center;
      color: #8f7a66;
      font-weight: 600;
    }

    .note {
      margin-top: 8px;
      text-align: center;
      color: #9d9184;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="head">
      <h1>2048</h1>
      <div class="stats">
        <div class="score-box">分数<strong id="score">0</strong></div>
        <div class="score-box">最高<strong id="best">0</strong></div>
      </div>
    </div>

    <div class="toolbar">
      <div>方向键或滑动移动方块</div>
      <button id="newGameBtn">新游戏</button>
    </div>

    <div class="board-wrap">
      <div class="board-bg" id="boardBg"></div>
      <div class="board-tiles" id="boardTiles"></div>
    </div>

    <div class="message" id="message"></div>
    <div class="note">合成 2048 即获胜，仍可继续挑战更高分。</div>
  </div>

  <script>
    (() => {
      const size = 4;
      const boardBg = document.getElementById("boardBg");
      const boardTiles = document.getElementById("boardTiles");
      const scoreNode = document.getElementById("score");
      const bestNode = document.getElementById("best");
      const messageNode = document.getElementById("message");
      const newGameBtn = document.getElementById("newGameBtn");

      let board = [];
      let score = 0;
      let best = Number(localStorage.getItem("best2048") || 0);
      let won = false;
      let touchStartX = 0;
      let touchStartY = 0;

      bestNode.textContent = String(best);

      function emptyBoard() {
        return Array.from({ length: size }, () => Array(size).fill(0));
      }

      function randomEmptyCell() {
        const spaces = [];
        board.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value === 0) spaces.push({ x, y });
          });
        });
        if (spaces.length === 0) return null;
        return spaces[Math.floor(Math.random() * spaces.length)];
      }

      function addRandomTile(forceTwo = false) {
        const spot = randomEmptyCell();
        if (!spot) return false;
        board[spot.y][spot.x] = forceTwo ? 2 : (Math.random() < 0.9 ? 2 : 4);
        return true;
      }

      function render() {
        boardTiles.innerHTML = "";
        for (let y = 0; y < size; y += 1) {
          for (let x = 0; x < size; x += 1) {
            const value = board[y][x];
            const cell = document.createElement("div");
            cell.className = "tile " + valueClass(value);
            cell.textContent = value === 0 ? "" : String(value);
            boardTiles.appendChild(cell);
          }
        }
        scoreNode.textContent = String(score);
      }

      function valueClass(value) {
        if (value === 0) return "v-0";
        if (value <= 2048) return "v-" + value;
        return "v-max";
      }

      function slideRow(row) {
        const noZero = row.filter((v) => v !== 0);
        for (let i = 0; i < noZero.length - 1; i += 1) {
          if (noZero[i] === noZero[i + 1]) {
            noZero[i] *= 2;
            score += noZero[i];
            noZero[i + 1] = 0;
            if (noZero[i] === 2048) {
              won = true;
            }
            i += 1;
          }
        }
        const compact = noZero.filter((v) => v !== 0);
        while (compact.length < size) compact.push(0);
        return compact;
      }

      function transpose(grid) {
        return grid[0].map((_, i) => grid.map((row) => row[i]));
      }

      function reverseRows(grid) {
        return grid.map((row) => row.slice().reverse());
      }

      function moveLeft(grid) {
        let moved = false;
        const next = grid.map((row, idx) => {
          const result = slideRow(row);
          if (!moved && result.some((v, i) => v !== row[i])) {
            moved = true;
          }
          return result;
        });
        return { next, moved };
      }

      function move(direction) {
        const snapshot = board.map((row) => row.slice());
        let result;

        if (direction === "left") {
          result = moveLeft(snapshot);
          board = result.next;
        } else if (direction === "right") {
          const reversed = reverseRows(snapshot);
          result = moveLeft(reversed);
          board = reverseRows(result.next);
        } else if (direction === "up") {
          const transposed = transpose(snapshot);
          result = moveLeft(transposed);
          board = transpose(result.next);
        } else if (direction === "down") {
          const transposed = transpose(snapshot);
          const reversed = reverseRows(transposed);
          result = moveLeft(reversed);
          board = transpose(reverseRows(result.next));
        } else {
          return;
        }

        if (!result.moved) return;

        addRandomTile();
        if (score > best) {
          best = score;
          bestNode.textContent = String(best);
          localStorage.setItem("best2048", String(best));
        }

        render();
        if (won) {
          setMessage("已合成 2048，继续冲击更高分。");
          won = false;
        } else if (isGameOver()) {
          setMessage("没有可移动的方块了，点击“新游戏”重来。");
        } else {
          setMessage("");
        }
      }

      function isGameOver() {
        for (let y = 0; y < size; y += 1) {
          for (let x = 0; x < size; x += 1) {
            const v = board[y][x];
            if (v === 0) return false;
            if (x < size - 1 && board[y][x + 1] === v) return false;
            if (y < size - 1 && board[y + 1][x] === v) return false;
          }
        }
        return true;
      }

      function setMessage(text) {
        messageNode.textContent = text;
      }

      function newGame() {
        board = emptyBoard();
        score = 0;
        won = false;
        addRandomTile(true);
        addRandomTile(true);
        setMessage("");
        render();
      }

      document.addEventListener("keydown", (event) => {
        const keyMap = {
          ArrowLeft: "left",
          ArrowRight: "right",
          ArrowUp: "up",
          ArrowDown: "down"
        };
        const direction = keyMap[event.key];
        if (!direction) return;
        event.preventDefault();
        move(direction);
      });

      window.addEventListener("touchstart", (event) => {
        const t = event.changedTouches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
      }, { passive: true });

      window.addEventListener("touchend", (event) => {
        const t = event.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        if (Math.max(Math.abs(dx), Math.abs(dy)) < 30) return;
        if (Math.abs(dx) > Math.abs(dy)) {
          move(dx > 0 ? "right" : "left");
        } else {
          move(dy > 0 ? "down" : "up");
        }
      }, { passive: true });

      newGameBtn.addEventListener("click", newGame);

      for (let i = 0; i < size * size; i += 1) {
        const cell = document.createElement("div");
        cell.className = "bg-cell";
        boardBg.appendChild(cell);
      }

      newGame();
    })();
  </script>
</body>
</html>
